// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: api/pin/pin.proto

package pin

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PinClient is the client API for Pin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PinClient interface {
	Add(ctx context.Context, in *AddReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Ls(ctx context.Context, in *LsReq, opts ...grpc.CallOption) (Pin_LsClient, error)
	IsPinned(ctx context.Context, in *IsPinnedReq, opts ...grpc.CallOption) (*IsPinnedResp, error)
	Rm(ctx context.Context, in *RmReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *UpdateReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Verify(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Pin_VerifyClient, error)
}

type pinClient struct {
	cc grpc.ClientConnInterface
}

func NewPinClient(cc grpc.ClientConnInterface) PinClient {
	return &pinClient{cc}
}

func (c *pinClient) Add(ctx context.Context, in *AddReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.ipfs.pin.Pin/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pinClient) Ls(ctx context.Context, in *LsReq, opts ...grpc.CallOption) (Pin_LsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Pin_ServiceDesc.Streams[0], "/api.ipfs.pin.Pin/Ls", opts...)
	if err != nil {
		return nil, err
	}
	x := &pinLsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Pin_LsClient interface {
	Recv() (*PinInfo, error)
	grpc.ClientStream
}

type pinLsClient struct {
	grpc.ClientStream
}

func (x *pinLsClient) Recv() (*PinInfo, error) {
	m := new(PinInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pinClient) IsPinned(ctx context.Context, in *IsPinnedReq, opts ...grpc.CallOption) (*IsPinnedResp, error) {
	out := new(IsPinnedResp)
	err := c.cc.Invoke(ctx, "/api.ipfs.pin.Pin/IsPinned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pinClient) Rm(ctx context.Context, in *RmReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.ipfs.pin.Pin/Rm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pinClient) Update(ctx context.Context, in *UpdateReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.ipfs.pin.Pin/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pinClient) Verify(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Pin_VerifyClient, error) {
	stream, err := c.cc.NewStream(ctx, &Pin_ServiceDesc.Streams[1], "/api.ipfs.pin.Pin/Verify", opts...)
	if err != nil {
		return nil, err
	}
	x := &pinVerifyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Pin_VerifyClient interface {
	Recv() (*VerifyResp, error)
	grpc.ClientStream
}

type pinVerifyClient struct {
	grpc.ClientStream
}

func (x *pinVerifyClient) Recv() (*VerifyResp, error) {
	m := new(VerifyResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PinServer is the server API for Pin service.
// All implementations must embed UnimplementedPinServer
// for forward compatibility
type PinServer interface {
	Add(context.Context, *AddReq) (*emptypb.Empty, error)
	Ls(*LsReq, Pin_LsServer) error
	IsPinned(context.Context, *IsPinnedReq) (*IsPinnedResp, error)
	Rm(context.Context, *RmReq) (*emptypb.Empty, error)
	Update(context.Context, *UpdateReq) (*emptypb.Empty, error)
	Verify(*emptypb.Empty, Pin_VerifyServer) error
	mustEmbedUnimplementedPinServer()
}

// UnimplementedPinServer must be embedded to have forward compatible implementations.
type UnimplementedPinServer struct {
}

func (UnimplementedPinServer) Add(context.Context, *AddReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedPinServer) Ls(*LsReq, Pin_LsServer) error {
	return status.Errorf(codes.Unimplemented, "method Ls not implemented")
}
func (UnimplementedPinServer) IsPinned(context.Context, *IsPinnedReq) (*IsPinnedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPinned not implemented")
}
func (UnimplementedPinServer) Rm(context.Context, *RmReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rm not implemented")
}
func (UnimplementedPinServer) Update(context.Context, *UpdateReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPinServer) Verify(*emptypb.Empty, Pin_VerifyServer) error {
	return status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedPinServer) mustEmbedUnimplementedPinServer() {}

// UnsafePinServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PinServer will
// result in compilation errors.
type UnsafePinServer interface {
	mustEmbedUnimplementedPinServer()
}

func RegisterPinServer(s grpc.ServiceRegistrar, srv PinServer) {
	s.RegisterService(&Pin_ServiceDesc, srv)
}

func _Pin_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PinServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ipfs.pin.Pin/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PinServer).Add(ctx, req.(*AddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pin_Ls_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PinServer).Ls(m, &pinLsServer{stream})
}

type Pin_LsServer interface {
	Send(*PinInfo) error
	grpc.ServerStream
}

type pinLsServer struct {
	grpc.ServerStream
}

func (x *pinLsServer) Send(m *PinInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Pin_IsPinned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsPinnedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PinServer).IsPinned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ipfs.pin.Pin/IsPinned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PinServer).IsPinned(ctx, req.(*IsPinnedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pin_Rm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RmReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PinServer).Rm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ipfs.pin.Pin/Rm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PinServer).Rm(ctx, req.(*RmReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pin_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PinServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ipfs.pin.Pin/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PinServer).Update(ctx, req.(*UpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pin_Verify_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PinServer).Verify(m, &pinVerifyServer{stream})
}

type Pin_VerifyServer interface {
	Send(*VerifyResp) error
	grpc.ServerStream
}

type pinVerifyServer struct {
	grpc.ServerStream
}

func (x *pinVerifyServer) Send(m *VerifyResp) error {
	return x.ServerStream.SendMsg(m)
}

// Pin_ServiceDesc is the grpc.ServiceDesc for Pin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Pin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ipfs.pin.Pin",
	HandlerType: (*PinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Pin_Add_Handler,
		},
		{
			MethodName: "IsPinned",
			Handler:    _Pin_IsPinned_Handler,
		},
		{
			MethodName: "Rm",
			Handler:    _Pin_Rm_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Pin_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Ls",
			Handler:       _Pin_Ls_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Verify",
			Handler:       _Pin_Verify_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/pin/pin.proto",
}
